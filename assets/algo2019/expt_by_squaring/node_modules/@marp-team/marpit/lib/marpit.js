"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _markdownIt = _interopRequireDefault(require("markdown-it"));

var _wrap_array = _interopRequireDefault(require("./helpers/wrap_array"));

var _theme_set = _interopRequireDefault(require("./theme_set"));

var _element = require("./element");

var _apply = _interopRequireDefault(require("./markdown/directives/apply"));

var _background_image = _interopRequireDefault(require("./markdown/background_image"));

var _collect = _interopRequireDefault(require("./markdown/collect"));

var _comment = _interopRequireDefault(require("./markdown/comment"));

var _container = _interopRequireDefault(require("./markdown/container"));

var _fragment = _interopRequireDefault(require("./markdown/fragment"));

var _header_and_footer = _interopRequireDefault(require("./markdown/header_and_footer"));

var _heading_divider = _interopRequireDefault(require("./markdown/heading_divider"));

var _inline_svg = _interopRequireDefault(require("./markdown/inline_svg"));

var _parse = _interopRequireDefault(require("./markdown/directives/parse"));

var _parse_image = _interopRequireDefault(require("./markdown/parse_image"));

var _slide = _interopRequireDefault(require("./markdown/slide"));

var _slide_container = _interopRequireDefault(require("./markdown/slide_container"));

var _assign = _interopRequireDefault(require("./markdown/style/assign"));

var _parse2 = _interopRequireDefault(require("./markdown/style/parse"));

var _sweep = _interopRequireDefault(require("./markdown/sweep"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classPrivateFieldSet(receiver, privateMap, value) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to set private field on non-instance"); } var descriptor = privateMap.get(receiver); if (descriptor.set) { descriptor.set.call(receiver, value); } else { if (!descriptor.writable) { throw new TypeError("attempted to set read only private field"); } descriptor.value = value; } return value; }

function _classPrivateFieldGet(receiver, privateMap) { if (!privateMap.has(receiver)) { throw new TypeError("attempted to get private field on non-instance"); } var descriptor = privateMap.get(receiver); if (descriptor.get) { return descriptor.get.call(receiver); } return descriptor.value; }

const defaultOptions = {
  container: _element.marpitContainer,
  headingDivider: false,
  looseYAML: false,
  markdown: 'commonmark',
  printable: true,
  slideContainer: false,
  inlineSVG: false,
  // Depreacted options
  backgroundSyntax: true,
  filters: true,
  inlineStyle: true,
  scopedStyle: true
};

const warnDeprecatedOpts = opts => {
  for (const opt of ['backgroundSyntax', 'filters', 'inlineStyle', 'scopedStyle']) {
    if (Object.prototype.hasOwnProperty.call(opts, opt)) {
      console.warn(`Deprecation warning: ${opt} option has been deprecated and would not be able to disable in v1.x.x.`);
    }
  }
};
/**
 * Parse Marpit Markdown and render to the slide HTML/CSS.
 */


class Marpit {
  /**
   * Create a Marpit instance.
   *
   * @param {Object} [opts]
   * @param {false|Element|Element[]}
   *     [opts.container={@link module:element.marpitContainer}] Container
   *     element(s) wrapping whole slide deck.
   * @param {false|number|number[]} [opts.headingDivider=false] Start a new
   *     slide page at before of headings. it would apply to headings whose
   *     larger than or equal to the specified level if a number is given, or
   *     ONLY specified levels if a number array.
   * @param {boolean} [opts.looseYAML=false] Allow loose YAML for directives.
   * @param {string|Object|Array} [opts.markdown='commonmark'] markdown-it
   *     initialize option(s).
   * @param {boolean} [opts.printable=true] Make style printable to PDF.
   * @param {false|Element|Element[]} [opts.slideContainer] Container element(s)
   *     wrapping each slide sections.
   * @param {boolean} [opts.inlineSVG=false] Wrap each sections by inline SVG.
   *     _(Experimental)_
   *
   * @param {boolean} [opts.backgroundSyntax=true] *[DEPREACTED]* Support
   *     markdown image syntax with the alternate text including `bg`. Normally
   *     it converts into spot directives about background image. If `inlineSVG`
   *     is enabled, it supports the advanced backgrounds.
   * @param {boolean} [opts.filters=true] *[DEPREACTED]*  Support filter syntax
   *     for markdown image. It can apply to inline image and the advanced
   *     backgrounds.
   * @param {boolean} [opts.inlineStyle=true] *[DEPREACTED]* Recognize `<style>`
   *     elements to append additional styles to theme. When it is `true`,
   *     Marpit will parse style regardless markdown-it's `html` option.
   * @param {boolean} [opts.scopedStyle=true] *[DEPREACTED]*  Support scoping
   *     inline style to the current slide through `<style scoped>` when
   *     `inlineStyle` is enabled.
   */
  constructor(opts = {}) {
    _markdown.set(this, {
      writable: true,
      value: undefined
    });

    // Output warning of deprecated option
    warnDeprecatedOpts(opts);
    /**
     * The current options for this instance.
     *
     * This property is read-only and marked as immutable. You cannot change the
     * value of options after creating instance.
     *
     * @member {Object} options
     * @memberOf Marpit
     * @readonly
     */

    Object.defineProperty(this, 'options', {
      enumerable: true,
      value: Object.freeze(_objectSpread({}, defaultOptions, opts))
    });
    /**
     * Definitions of the custom directive.
     *
     * It has the assignable `global` and `local` object. They have consisted of
     * the directive name as a key, and parser function as a value. The parser
     * should return the validated object for updating meta of markdown-it
     * token.
     *
     * @member {Object} customDirectives
     * @memberOf Marpit
     * @readonly
     */

    Object.defineProperty(this, 'customDirectives', {
      value: Object.seal({
        global: {},
        local: {}
      })
    });
    /**
     * @type {ThemeSet}
     */

    this.themeSet = new _theme_set.default();
    this.applyMarkdownItPlugins(new _markdownIt.default(...(0, _wrap_array.default)(this.options.markdown)));
  }
  /**
   * @type {MarkdownIt}
   */


  get markdown() {
    return _classPrivateFieldGet(this, _markdown);
  }

  set markdown(md) {
    if (_classPrivateFieldGet(this, _markdown) && _classPrivateFieldGet(this, _markdown).marpit) delete _classPrivateFieldGet(this, _markdown).marpit;

    _classPrivateFieldSet(this, _markdown, md);

    if (md) {
      Object.defineProperty(md, 'marpit', {
        configurable: true,
        value: this
      });
    }
  }
  /**
   * The plugin interface of markdown-it for current Marpit instance.
   *
   * This is useful to integrate Marpit with the other markdown-it based parser.
   *
   * @type {Function}
   * @readonly
   */


  get markdownItPlugins() {
    return this.applyMarkdownItPlugins.bind(this);
  }
  /** @private */


  applyMarkdownItPlugins(md) {
    this.markdown = md;
    md.use(_comment.default).use(_parse2.default).use(_slide.default).use(_parse.default).use(_apply.default).use(_header_and_footer.default).use(_heading_divider.default).use(_slide_container.default).use(_container.default).use(_parse_image.default).use(_sweep.default).use(_inline_svg.default).use(_assign.default).use(_background_image.default).use(_fragment.default).use(_collect.default);
  }
  /**
   * @typedef {Object} Marpit~RenderResult
   * @property {string|string[]} html Rendered HTML.
   * @property {string} css Rendered CSS.
   * @property {string[][]} comments Parsed HTML comments per slide pages,
   *     excepted YAML for directives. It would be useful for presenter notes.
   */

  /**
   * Render Markdown into HTML and CSS string.
   *
   * @param {string} markdown A Markdown string.
   * @param {Object} [env={}] Environment object for passing to markdown-it.
   * @param {boolean} [env.htmlAsArray=false] Output rendered HTML as array per
   *     slide.
   * @returns {Marpit~RenderResult} An object of rendering result.
   */


  render(markdown, env = {}) {
    return {
      html: this.renderMarkdown(markdown, env),
      css: this.renderStyle(this.lastGlobalDirectives.theme),
      comments: this.lastComments
    };
  }
  /**
   * Render Markdown by using `markdownIt#render`.
   *
   * This method is for internal. You can override this method if you have to
   * render with customized way.
   *
   * @private
   * @param {string} markdown A Markdown string.
   * @param {Object} [env] Environment object for passing to markdown-it.
   * @param {boolean} [env.htmlAsArray=false] Output rendered HTML as array per
   *     slide.
   * @returns {string|string[]} The result string(s) of rendering Markdown.
   */


  renderMarkdown(markdown, env = {}) {
    const tokens = this.markdown.parse(markdown, env);

    if (env.htmlAsArray) {
      return this.lastSlideTokens.map(slideTokens => this.markdown.renderer.render(slideTokens, this.markdown.options, env));
    }

    return this.markdown.renderer.render(tokens, this.markdown.options, env);
  }
  /**
   * Render style by using `themeSet#pack`.
   *
   * This method is for internal.
   *
   * @private
   * @param {string|undefined} theme Theme name.
   * @returns {string} The result string of rendering style.
   */


  renderStyle(theme) {
    return this.themeSet.pack(theme, this.themeSetPackOptions());
  }
  /** @private */


  themeSetPackOptions() {
    return {
      after: this.lastStyles ? this.lastStyles.join('\n') : undefined,
      containers: [...(0, _wrap_array.default)(this.options.container), ...(0, _wrap_array.default)(this.options.slideContainer)],
      inlineSVG: this.options.inlineSVG,
      printable: this.options.printable
    };
  }
  /**
   * Load the specified markdown-it plugin with given parameters.
   *
   * @param {Function} plugin markdown-it plugin.
   * @param {...*} params Params to pass into plugin.
   * @returns {Marpit} The called {@link Marpit} instance for chainable.
   */


  use(plugin, ...params) {
    plugin.call(this.markdown, this.markdown, ...params);
    return this;
  }

}

var _markdown = new WeakMap();

var _default = Marpit;
exports.default = _default;