"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _jsYaml = _interopRequireWildcard(require("js-yaml"));

var _directives = _interopRequireDefault(require("./directives"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {}; if (desc.get || desc.set) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } } newObj.default = obj; return newObj; } }

/** @module */

/**
 * Parse text as YAML by using js-yaml's FAILSAFE_SCHEMA.
 *
 * @alias module:markdown/directives/yaml
 * @param {String} text Target text.
 * @param {boolean} allowLoose By `true`, it try to parse loose YAML in defined
 *     directives.
 * @returns {Object|false} Return parse result, or `false` when failed to parse.
 */
const keyPattern = `[_$]?(?:${_directives.default.join('|')})`;
const looseMatcher = new RegExp(`^(${keyPattern}\\s*:)(.+)$`);
const specialChars = `["'{|>~&*`;

function parse(text) {
  try {
    const obj = _jsYaml.default.safeLoad(text, {
      schema: _jsYaml.FAILSAFE_SCHEMA
    });

    if (obj === null || typeof obj !== 'object') return false;
    return obj;
  } catch (e) {
    return false;
  }
}

function convertLoose(text) {
  let normalized = '';

  for (const line of text.split(/\r?\n/)) normalized += `${line.replace(looseMatcher, (original, prop, value) => {
    const trimmed = value.trim();
    if (trimmed.length === 0 || specialChars.includes(trimmed[0])) return original;
    const spaceLength = value.length - value.trimLeft().length;
    const spaces = value.substring(0, spaceLength);
    return `${prop}${spaces}"${trimmed.split('"').join('\\"')}"`;
  })}\n`;

  return normalized.trim();
}

var _default = (text, allowLoose) => parse(allowLoose ? convertLoose(text) : text);

exports.default = _default;