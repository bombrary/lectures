[メモリ]
実行中プログラムのデータはメモリよ呼ばれる場所に保管されている。メモリからデータを取り出したり、計算したり、またメモリにデータ格納するこができる。
どの場所にどのデータがあるのかが分かるようにするために、メモリには番地が割り当てられている。この番地をアドレスという。
直接アドレスを指定してデータを取り出したりすることはない。Cではデータを変数という形で扱っているからだ。変数aを宣言したとき、
「001XAGD番地のデータを変数aとして割り当てる」
という処理が自動で行われる。なので普段私たちがアドレスを意識することはない。
配列が宣言されたとき、配列の各要素はメモリ上に並んで割り当てが行われる。
プログラムの終了時、メモリ上に割り当てられた変数はもう使われない。メモリ上の割り当てが解除される。
変数のアドレスを知るためには、アドレス演算子を用いる。
&a
たいう書式で、変数aのアドレスを得ることができる。
ちなみにprintfでアドレスを出力したいなら、%pを用いる。
変数にはサイズがあると以前に述べた。よって、変数にはメモリの複数の番地が割り当てられている可能性がある。

[ポインタ]
さて、いままではメモリやアドレスを意識しなくてもプログラミングできたのだが、ポインタを理解するためにはメモリを理解しなければならない。
ポインタとは、「アドレスを格納する特殊な変数」のことである。そのアドレスを利用して、間接的に他の変数の値を得たり、変えたりできる。
ポインタは次のように宣言する
int *p
int型の変数のアドレスを格納することができるポインタを宣言する。これを「int型へのポインタ型の変数」という。
「アドレスを格納するだけなのに、なぜint型のアドレス、char型のアドレスを格納する変数と別れているのか」と思うかもしれない。この理由は、後のポインタ演算で明らかになる。
ポインタを使うためには、まず変数のアドレスを代入する
p=&a
アスタリスクを付けて*pとすると、*pはまさにaそのものとなる。
例を交えながら詳しく述べる。たとえば
b=*p+1
とすると、*pはpに入っているアドレスに割り当てられた値、すなわちaの値に読み変えられる。
さらに、
*p=10
とすると、pに入っているアドレスに割り当てられた領域に10を代入する。つまりaに10が代入される。
[ポインタ演算]
ポインタの値、つまりアドレスを足し算してみよう。int型、double型それぞれについて1加えて、そのアドレスを表示してみる。
(サンプル)
1加えた筈なのに、int型ではアドレスが4、double型では8増えている。
実は、型によって1加えた時に増えるアドレスの量が異なる。その量は型のサイズである。なぜこんな不思議な演算なのかは、次の項目で明らかになる。

[例]
xの値とyの値を入れ換える関数swapを実装してみよう。
ふつうに
void swap(int x, int y)
とすると、xとyの値があくまでコピーされるだけで、交換される訳ではない。
アドレスを渡せば、値を間接的に弄ることができる
void swap(int *x, int *y)

[配列とポインタ]
配列をa、その添字をiと書こう。
実は、aそのものは「配列の先頭要素のアドレス」を表す。つまり、aと&a[0]は全く同じ意味で、*aはa[0]と全く同じ意味である。
さらに、次の2式は全く同じ意味である。
a[i]
*(a+i)
前者は「配列aのi番目の要素」、後者は「アドレスa+iの指す値」を意味する。
前者は後者の、ただの省略記法に過ぎない。
アドレスの足し算を思いだそう。アドレスに1加えると、アドレスの値は配列の型のバイト数分動く。ということは、a+iの示すアドレスは、aからi×(型のサイズ[バイト])先のアドレスを表す。これは図で見ると分かりやすい。
(図)
たとえばint型の変数が4バイトなら、ポインタ演算の良い性質によって4ずつ飛ぶので、a+iで配列のi番目の要素にアクセスできる。

[関数に配列へのポインタを渡す]
C言語においては、配列のそのものを引数として関数に渡すことはできない。代わりにポインタを渡す。
ポインタを渡せば、呼び出した関数は配列がどこにあるのかを知ることができるため、配列の値を利用できる。
配列の要素はメモリ上に連続して並んでいるため、*(a+i)の形式でアクセスできる。*(a+i)とa[i]は同じ意味だったから、結局いつもの配列と同じように使える。
ここで注意したいのは、その配列を渡せば、その配列を直接弄ることになる、ということだ。変数を関数に渡すときは一度値のコピーが行われるため、実引数として与えられた変数そのものを直接弄っているわけではない。しかしポインタを渡せば、値を直接書き換えられる。