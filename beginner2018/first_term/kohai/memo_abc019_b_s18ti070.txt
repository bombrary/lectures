まず入力を確認してみます。
一桁ならOK: aaaaabbbbcccc -> a5b4c4
二桁の場合、下二桁が0でない場合はOK: aaaaaaaaaaaa -> a12
二桁の場合、下一桁が0の場合がだめ。0が出力されない: aaaaaaaaaa -> a1

このように、何かの変化の境界点のことをコーナーケースといいます。
今回の場合、コーナーケースは「繰り上がりのケース」です。
一般に、コーナーケースではバグが起きやすいです。
その辺りに注意してプログラムを組んでみたり、バグ発見のときにコーナーケースを試したりするといいかもしれません。

さらに、「0まわりでバグがありそうだと」考えて、次のケースでバグが起こることを発見します。
aが103個並んだ列 -> a13

なぜこのようなことが起こったのかを、new_cntの値とソースコードを読みながら確認してみます。
文字列の長さの制約から1000を超えることはないのですが、説明の都合上、はじめはnew_cnt = 2056であることをを例にして処理を追ってみます。
まず、
if(new_cnt/1000!=0){ ... }
の記述から、new_cnt = 56です。このとき、2の右にあった0の情報が失われてしまいます。
これは0が最上位に来てしまうためです。
よって、次の
if(new_cnt/100!=0){ ... }
の処理が行われません。new_cnt/100=0.56であり、小数点切り捨てで0になってしまうためです。

これを解決するための手段はおそらく色々ありますが、なるべく最小限の修正に収まるようにコードを変えてみます。
とにかく途中に0を含んでいるような数もうまく表示したいわけです。
ということは、「0が桁の途中に現れる数なのかどうか」という情報を保持しておかないといけません。
そこで、「もとの数が1000以上か、100以上か、10以上か」でif文を書けばよさそうです。

もとの数を保持しておくために、新たに次の変数tmp_cntを追加します。
int tmp_cnt = new_cnt;
if文をうまく書き換えた結果がabc019_b_s18ti070.cになります。

一応、僕の書いた解答も下に載せておきます(abc019_b.c)。
競プロ的な考え方ですが、あくまで出力が目的のものであればよいので、
新しい文字列を作ることなく、数えるたびにprintfで直接出力してしまっています。
文字列を作らずに、出力をうまく工夫して解答できるかもしれないことを念頭におくといいかもしれません。
他に、文字列作らなくてもprintfだけでどうにかなってしまう問題には
ABC049_B, ABC062_Bがあります。

しかし平塚君のコードのように、文字列を一から作っていくような技術は重要なので決して悪いコードではないです。